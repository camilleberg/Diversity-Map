get_acs(geography = "place",
variables = "B05002_001",
year = 2020,
cache_table = T,
show_call = TRUE)
cities <- get_acs(geography = "place",
variables = "B05002_001",
year = 2020,
cache_table = T,
show_call = TRUE)
cities$NAME[which(cities$NAME == "Phoenix city, Arizona")]
readxl::read_xlsx("div_map_categories.xlsx", sheet = cities)
readxl::read_xlsx("div_map_categories.xlsx", sheet = cities)
readxl::read_xlsx("div_map_categories.xlsx", sheet = cities)
readxl::read_xlsx("div_map_categories.xlsx", sheet = "cities")
cities_of_int <- readxl::read_xlsx("div_map_categories.xlsx", sheet = "cities")
cities %>%
select(NAME %in% cities_of_int)
library(dplyr)
# loading libraries
remotes::install_github("walkerke/tidycensus")
devtools::install_github("r-spatial/leafpop")
library(tidycensus)
library(tidyverse)
library(leaflet)
library(leafpop)
library(mapview)
library(sf)
library(stringr)
library(plotly)
library(readr)
library(readxl)
library(stringr)
library(dplyr)
library(janitor)
cities <- get_acs(geography = "place",
variables = "B05002_001",
year = 2020,
cache_table = T,
show_call = TRUE)
cities_of_int <- readxl::read_xlsx("div_map_categories.xlsx", sheet = "cities")
cities %>%
select(NAME %in% cities_of_int)
View(cities_of_int)
unlist(cities_of_int)
cities %>%
select(NAME %in% unlist(cities_of_int))
cities %>%
filter(NAME %in% cities_of_int)
cities %>%
filter(NAME %in% unlist(cities_of_int))
### CITY
cities_of_int <- readxl::read_xlsx("div_map_categories.xlsx", sheet = "cities")
cities_raw <- get_acs(geography = "place",
variable = acs_pull_labels, #34,
output = "wide",
year = 2020,
cache_table = T,
show_call = TRUE)
cities_raw <- cities_raw %>%
filter(NAME %in% unlist(cities_of_int)) %>%
select(!ends_with("M"))
View(cities_raw)
rm(cities_raw)
cities_raw <- get_acs(geography = "place",
variable = acs_pull_labels, #34,
output = "wide",
year = 2020,
cache_table = T,
show_call = TRUE)
cities_raw <- get_acs(geography = "place",
variable = acs_pull_labels, #34,
output = "wide",
year = 2020,
cache_table = T,
show_call = TRUE)
grouping_fxn <- function(div_label, city = F) {
x <- which(colnames(div_groups_labels) == paste0(div_label))
if(city == T){
other_var_small <- cities_small
}
# this basically selects the relevant census variables related to each group
# and then adds them
dat <- other_var_small %>%
as_tibble() %>%
select(
colnames(other_var_small)[colnames(other_var_small) %in% (div_groups_labels[,x] %>% array())[[1]]]
) %>%
mutate(val = rowSums(across())) %>% select(val) %>%
rename(!!sym(div_label) := val)
return(dat)
}
for(i in 1:length(colnames(div_groups_labels))) {
other_var_groups <- cbind(other_var_groups, grouping_fxn(colnames(div_groups_labels)[i]))
}
View(other_var_groups)
## Essentially, all the steps from earlier wil just be repeated here
cities_small <- cities_raw %>%
filter(NAME %in% unlist(cities_of_int)) %>%
select(!ends_with("M"))
rm(cities_raw)
# removing the E from the end of the variable names
colnames(cities_small)[3:length(colnames(cities_small))-1] <-
substr(colnames(cities_small)[3:length(colnames(cities_small))-1], 1, nchar(colnames(cities_small)[3:length(colnames(cities_small))-1])-1)
View(cities_small)
# initializing the df
cities_groups <- tibble(GEOID = cities_small$GEOID,
NAME = cities_small$NAM, # I don't know why it's doing this but
geometry = cities_small$geometry)
# initializing the df
cities_groups <- tibble(GEOID = cities_small$GEOID,
NAME = cities_small$NAM) # I don't know why it's doing this but
for(i in 1:length(colnames(div_groups_labels))) {
cities_groups <- cbind(cities_groups, grouping_fxn(colnames(div_groups_labels)[i], city = T))
}
View(cities_groups)
educ_pull_city_raw <- cities_groups %>%
select(c(GEOID, NAME, geometry, starts_with("educ")))
educ_pull_city_raw <- cities_groups %>%
select(c(GEOID, NAME, geometry, starts_with("educ")))
educ_pull_city_raw <- cities_groups %>%
select(c(GEOID, NAME, starts_with("educ")))
pob_pull_city_raw <- cities_groupss %>%
select(c(GEOID, NAME, starts_with("pob")))
age_pull_city_raw <- cities_groups %>%
select(c(GEOID, NAME, starts_with("age")))
pob_pull_city_raw <- cities_groups %>%
select(c(GEOID, NAME, starts_with("pob")))
hh_income_city_pull_raw <- cities_groups %>%
select(c(GEOID, NAME, starts_with("hh_income")))
div_index_fxn <- function(dat, var_type, geography) {
if(geography == "tract") {
slice <- dat %>%
rename(total = ends_with("Total")) %>%
select(!c(GEOID, NAME, geometry))
} else if(geography == "nbhd") {
slice <- dat %>%
rename(total = ends_with("Total")) %>%
select(-tract20_nbhd) %>%
mutate_all(as.numeric)
} else if(geography == "city") {
slice <- dat %>%
rename(total = ends_with("Total")) %>%
select(!c(GEOID, NAME))
}
# this calculates the divraw numbers
for(i in 1:(ncol(slice))) {
slice <- cbind(slice, div_prop(slice[, i], slice$total))
colnames(slice)[ncol(slice)] <- paste0(colnames(slice)[i], "_calc")
}
# this takes all the variables and adds them based off which group they've been assigned to
# i.e. this is the function that creates the index
group_calc_fxn <- function(group_label) {
label <- paste0("val_", paste0(group_label))
return(slice %>%
select(ends_with("calc")) %>%
mutate(
div_val = select(., starts_with(paste0(group_label))) %>% rowSums()
) %>% select(div_val) %>% mutate(div_val = 1 - div_val) %>%
rename(!!sym(label):= div_val)
)
}
# variable/group names
group_names <- categories$group_labels[grepl(paste0("^", var_type), categories$group_labels)]
# initializing empty df
div_ind <- group_calc_fxn(group_names[1])
# looping through
for(i in 2:length(group_names)) {
div_ind <- cbind(div_ind, group_calc_fxn(group_names[i]))
}
return(div_ind[unique(colnames(div_ind))])
}
pob_div_city <- cbind(pob_pull_city_raw, div_index_fxn(pob_pull_city_raw, "pob", geography = "city")[-1])
View(pob_div_city)
i
educ_div_city <- cbind(educ_pull_city_raw, div_index_fxn(educ_pull_city_raw, "educ", geography = "city")[-1])
age_div_city <- cbind(age_pull_city_raw, div_index_fxn(age_pull_city_raw, "age", geography = "city")[-1])
hh_income_div_city <- cbind(hh_income_pull_city_raw, div_index_fxn(hh_income_pull_city_raw, "hh_income", geography = "city")[-1])
hh_income_city_pull_raw <- cities_groups %>%
select(c(GEOID, NAME, starts_with("hh_income")))
hh_income_div_city <- cbind(hh_income_pull_city_raw, div_index_fxn(hh_income_pull_city_raw, "hh_income", geography = "city")[-1])
hh_income_oull_city_raw <- cities_groups %>%
select(c(GEOID, NAME, starts_with("hh_income")))
hh_income_div_city <- cbind(hh_income_pull_city_raw, div_index_fxn(hh_income_pull_city_raw, "hh_income", geography = "city")[-1])
hh_income_pull_city_raw <- cities_groups %>%
select(c(GEOID, NAME, starts_with("hh_income")))
hh_income_div_city <- cbind(hh_income_pull_city_raw, div_index_fxn(hh_income_pull_city_raw, "hh_income", geography = "city")[-1])
write_rds(pob_div_tract, "Place_of_Birth_diversity_div_tract.RDS")
write_rds(pob_div_neigh, "Place_of_Birth_diversity_neighborhood.RDS")
write_rds(pob_div_cities, "Place_of_Birth_diversity_div_cities.RDS")
pob_div_city <- cbind(pob_pull_city_raw, div_index_fxn(pob_pull_city_raw, "pob", geography = "city")[-1])
educ_div_city <- cbind(educ_pull_city_raw, div_index_fxn(educ_pull_city_raw, "educ", geography = "city")[-1])
age_div_city <- cbind(age_pull_city_raw, div_index_fxn(age_pull_city_raw, "age", geography = "city")[-1])
hh_income_div_city <- cbind(hh_income_pull_city_raw, div_index_fxn(hh_income_pull_city_raw, "hh_income", geography = "city")[-1])
write_rds(pob_div_tract, "Place_of_Birth_diversity_div_tract.RDS")
write_rds(pob_div_neigh, "Place_of_Birth_diversity_neighborhood.RDS")
write_rds(pob_div_cities, "Place_of_Birth_diversity_div_cities.RDS")
write_rds(educ_div_tract, "Education_diversity_div_tract.RDS")
write_rds(educ_div_neigh, "Education_diversity_neighborhood.RDS")
write_rds(pob_div_cities, "Education_diversity_div_cities.RDS")
write_rds(age_div_tract, "Age_diversity_div_tract.RDS")
write_rds(age_div_neigh, "Age_diversity_neighborhood.RDS")
write_rds(pob_div_cities, "Age_diversity_div_cities.RDS")
write_rds(pob_div_tract, "Place_of_Birth_diversity_div_tract.RDS")
write_rds(pob_div_neigh, "Place_of_Birth_diversity_neighborhood.RDS")
write_rds(pob_div_city, "Place_of_Birth_diversity_div_cities.RDS")
write_rds(educ_div_tract, "Education_diversity_div_tract.RDS")
write_rds(educ_div_neigh, "Education_diversity_neighborhood.RDS")
write_rds(pob_div_city, "Education_diversity_div_cities.RDS")
write_rds(age_div_tract, "Age_diversity_div_tract.RDS")
write_rds(age_div_neigh, "Age_diversity_neighborhood.RDS")
write_rds(pob_div_city, "Age_diversity_div_cities.RDS")
write_rds(hh_income_div_tract, "Household_Income_diversity_div_tract.RDS")
write_rds(hh_income_div_neigh, "Household_Income_diversity_neighborhood.RDS")
write_rds(pob_div_city, "Household_Income_diversity_div_cities.RDS")
write_rds(pob_div_tract, "Place_of_Birth_diversity_tract.RDS")
## SETUP ------------------------------------------------------------------
rm(list = ls())
# loading libraries
remotes::install_github("walkerke/tidycensus")
devtools::install_github("r-spatial/leafpop")
library(tidycensus)
library(tidyverse)
library(leaflet)
library(leafpop)
library(mapview)
library(sf)
library(stringr)
library(plotly)
library(readr)
library(readxl)
library(stringr)
library(dplyr)
library(janitor)
# note: you may need to run these libraries individually
## PULLING AND ORGANZIING THE DATA -----------------------------------------
VARS <- tidycensus::load_variables(dataset = 'acs5', year = 2020, cache = T)
# categories <- read_xlsx("Diversity Map Categories.xlsx")
categories <- readxl::read_xlsx("div_map_categories.xlsx", sheet = "categories")
# creating unique variable names
categories$var_names <- paste0(categories$title, "_", categories$group_name, "_",
str_replace_all(categories$var_description, " ", "_"))
categories$group_labels <- paste0(categories$title, "_", categories$group_name)
# adjusting for special characters in the income
categories$var_name_ending <- str_replace_all(categories$var_name_ending, "\\$", "\\\\$")
# initialing empty column to assign new var
categories$census_label <- NA
# looping through to fill with the relevant census var names
for(i in 1:nrow(categories)){
# selecting only the table of interest
table <- VARS %>%
filter(grepl(paste0("^", categories$table_name[i], "_"), VARS$name)) %>%
select(label, name)
# selecting from the table of interest
if(categories$title[i] == "educ" | categories$title[i] == "age") {
if(grepl("^High school", categories$var_name_ending[i])) {
# manually fixing the high school thing
male <- "B15002_011"; female <- "B15002_028"
} else {
# aggregating the male and female var names because they're segregated for educ
male <- table$name[grepl(paste0(categories$var_name_ending[i], "$"), table$label)][1]
female <- table$name[grepl(paste0(categories$var_name_ending[i], "$"), table$label)][2]
}
# assigning new label
categories$census_label[i] <- paste0(male, ",", female)
# NOTE: the comma here should match the comma later as a separator
} else {
# assigning new label
categories$census_label[i] <- table$name[grepl(paste0(categories$var_name_ending[i], "$"), table$label)]
}
}
# grouping and combining all the labels to the distinct groups
census_groups <- categories %>%
group_by(var_names) %>%
mutate(labels = paste0(census_label, collapse = ",")) %>%
distinct(labels)
# un-listing variable names
acs_pull_labels <- unlist(strsplit(unique(categories$census_label), ","))
acs_pull_labels <- acs_pull_labels[!acs_pull_labels == "NA"]
# fix NA issue later (this is related to the High School thing)
# pulling census data
other_var_pull_raw <- tidycensus::get_acs(geography = "tract",
variable = acs_pull_labels, #34,
output = "wide",
state = "MA",
county = "Suffolk",
geometry = TRUE,
year = 2020,
cache_table = T,
show_call = TRUE) %>%
filter(!(str_detect(NAME,"Census Tract 99")|str_detect(NAME,"Census Tract 18")
|str_detect(NAME,"Census Tract 17")|str_detect(NAME,"Census Tract 16")
|str_detect(NAME,"Census Tract 9812.01")|str_detect(NAME,"Census Tract 9801.01")))
# Removing margin of error columns
other_var_small <- other_var_pull_raw %>%
select(!ends_with("M"))
rm(other_var_pull_raw)
# removing the E from the end of the variable names
colnames(other_var_small)[3:length(colnames(other_var_small))-1] <-
substr(colnames(other_var_small)[3:length(colnames(other_var_small))-1], 1, nchar(colnames(other_var_small)[3:length(colnames(other_var_small))-1])-1)
# expand the categories into new table with variables for each column #
# initializing labeling conventio
col_var_names <- c()
for(i in 1:24) {
col_var_names[i] <- paste0("var.", i)
}
# 24 was chosen through looking at the data, but there's probably a way to soft-code it
# expanding out the var names into separate cells
census_groups_expanded <- left_join(census_groups,separate(census_groups, col = labels, into = col_var_names, sep = ","),
by = "var_names")
# making addition columns
div_groups_labels <- census_groups_expanded %>%
select(-labels) %>%
t() %>% as_tibble() %>%
row_to_names(row_number = 1)
# adding the calculated rows to the census data #
# initializing the df
other_var_groups <- tibble(GEOID = other_var_small$GEOID,
NAME = other_var_small$NAM, # I don't know why it's doing this but
geometry = other_var_small$geometry)
# selecting only those of interest and adding them
grouping_fxn <- function(div_label, city = F) {
x <- which(colnames(div_groups_labels) == paste0(div_label))
if(city == T){
other_var_small <- cities_small
}
# this basically selects the relevant census variables related to each group
# and then adds them
dat <- other_var_small %>%
as_tibble() %>%
select(
colnames(other_var_small)[colnames(other_var_small) %in% (div_groups_labels[,x] %>% array())[[1]]]
) %>%
mutate(val = rowSums(across())) %>% select(val) %>%
rename(!!sym(div_label) := val)
return(dat)
}
for(i in 1:length(colnames(div_groups_labels))) {
other_var_groups <- cbind(other_var_groups, grouping_fxn(colnames(div_groups_labels)[i]))
}
## ANALYZING THE DATA ------------------------------------------------------
# basically, for the value columns, it's the difference of 1 and the sum of all the diff categories
# from setup_cleaned.R
div_prop <- function(var, total_pop) {
x <- (var/total_pop)^2
return(x)
}
# separating the df into the general demographic variables
# NOTE: this part will be hard coded
educ_pull_raw <- other_var_groups %>%
select(c(GEOID, NAME, geometry, starts_with("educ")))
pob_pull_raw <- other_var_groups %>%
select(c(GEOID, NAME, geometry, starts_with("pob")))
age_pull_raw <- other_var_groups %>%
select(c(GEOID, NAME, geometry, starts_with("age")))
hh_income_pull_raw <- other_var_groups %>%
select(c(GEOID, NAME, geometry, starts_with("hh_income")))
# performing the calculations
div_index_fxn <- function(dat, var_type, geography) {
if(geography == "tract") {
slice <- dat %>%
rename(total = ends_with("Total")) %>%
select(!c(GEOID, NAME, geometry))
} else if(geography == "nbhd") {
slice <- dat %>%
rename(total = ends_with("Total")) %>%
select(-tract20_nbhd) %>%
mutate_all(as.numeric)
} else if(geography == "city") {
slice <- dat %>%
rename(total = ends_with("Total")) %>%
select(!c(GEOID, NAME))
}
# this calculates the divraw numbers
for(i in 1:(ncol(slice))) {
slice <- cbind(slice, div_prop(slice[, i], slice$total))
colnames(slice)[ncol(slice)] <- paste0(colnames(slice)[i], "_calc")
}
# this takes all the variables and adds them based off which group they've been assigned to
# i.e. this is the function that creates the index
group_calc_fxn <- function(group_label) {
label <- paste0("val_", paste0(group_label))
return(slice %>%
select(ends_with("calc")) %>%
mutate(
div_val = select(., starts_with(paste0(group_label))) %>% rowSums()
) %>% select(div_val) %>% mutate(div_val = 1 - div_val) %>%
rename(!!sym(label):= div_val)
)
}
# variable/group names
group_names <- categories$group_labels[grepl(paste0("^", var_type), categories$group_labels)]
# initializing empty df
div_ind <- group_calc_fxn(group_names[1])
# looping through
for(i in 2:length(group_names)) {
div_ind <- cbind(div_ind, group_calc_fxn(group_names[i]))
}
return(div_ind[unique(colnames(div_ind))])
}
# adding diversity index calculations to larger variable data frames
pob_div_tract <- cbind(pob_pull_raw, div_index_fxn(pob_pull_raw, "pob", geography = "tract")[-1])
educ_div_tract <- cbind(educ_pull_raw, div_index_fxn(educ_pull_raw, "educ", geography = "tract")[-1])
age_div_tract <- cbind(age_pull_raw, div_index_fxn(age_pull_raw, "age", geography = "tract")[-1])
hh_income_div_tract <- cbind(hh_income_pull_raw, div_index_fxn(hh_income_pull_raw, "hh_income", geography = "tract")[-1])
# this is to remove the total column
## NEIGHBORHOOD AND CITY ---------------------------------------------------
### NEIGHBORHOOD
TRACT_TO_NEIGHBORHOOD <- readxl::read_xlsx("geo20_tract_block group comparison.xlsx")
## for place of birth
pob_div_neigh <- pob_pull_raw %>%
left_join(TRACT_TO_NEIGHBORHOOD, by = c('NAME'='tract20')) %>%
filter((!is.na(tract20_nbhd))| pob_total_Total == 0) %>%
filter(tract20_nbhd != "_Census Tract 9901.01, Suffolk County, Massachusetts") %>%
as_tibble() %>%
select(-c(GEOID, NAME, geometry, GEO_ID, GEO_ID2)) %>%
group_by(tract20_nbhd) %>%
summarise(across(everything(), ~ sum(., is.na(.), 0)))
# adding Boston row
total <- c(tract20_nbhd="Citywide", apply(pob_div_neigh[,-1], FUN = sum, MAR = 2))
pob_div_neigh <- rbind(pob_div_neigh, total)
pob_div_neigh <- cbind(pob_div_neigh, div_index_fxn(pob_div_neigh, "pob", "nbhd")[-1])
## for education
educ_div_neigh <- educ_pull_raw %>%
left_join(TRACT_TO_NEIGHBORHOOD, by = c('NAME'='tract20')) %>%
filter((!is.na(tract20_nbhd))| educ_total_Total == 0) %>%
filter(tract20_nbhd != "_Census Tract 9901.01, Suffolk County, Massachusetts") %>%
as_tibble() %>%
select(-c(GEOID, NAME, geometry, GEO_ID, GEO_ID2)) %>%
group_by(tract20_nbhd) %>%
summarise(across(everything(), ~ sum(., is.na(.), 0)))
# adding Boston row
total <- c(tract20_nbhd="Citywide", apply(educ_div_neigh[,-1], FUN = sum, MAR = 2))
educ_div_neigh <- rbind(educ_div_neigh, total)
educ_div_neigh <- cbind(educ_div_neigh, div_index_fxn(educ_div_neigh, "educ", "nbhd")[-1])
## for age
age_div_neigh <- age_pull_raw %>%
left_join(TRACT_TO_NEIGHBORHOOD, by = c('NAME'='tract20')) %>%
filter((!is.na(tract20_nbhd))| age_total_Total == 0) %>%
filter(tract20_nbhd != "_Census Tract 9901.01, Suffolk County, Massachusetts") %>%
as_tibble() %>%
select(-c(GEOID, NAME, geometry, GEO_ID, GEO_ID2)) %>%
group_by(tract20_nbhd) %>%
summarise(across(everything(), ~ sum(., is.na(.), 0)))
# adding Boston row
total <- c(tract20_nbhd="Citywide", apply(age_div_neigh[,-1], FUN = sum, MAR = 2))
age_div_neigh <- rbind(age_div_neigh, total)
age_div_neigh <- cbind(age_div_neigh, div_index_fxn(age_div_neigh, "age", "nbhd")[-1])
## for household income
hh_income_div_neigh <- hh_income_pull_raw %>%
left_join(TRACT_TO_NEIGHBORHOOD, by = c('NAME'='tract20')) %>%
filter((!is.na(tract20_nbhd))| hh_income_total_Total == 0) %>%
filter(tract20_nbhd != "_Census Tract 9901.01, Suffolk County, Massachusetts") %>%
as_tibble() %>%
select(-c(GEOID, NAME, geometry, GEO_ID, GEO_ID2)) %>%
group_by(tract20_nbhd) %>%
summarise(across(everything(), ~ sum(., is.na(.), 0)))
# adding Boston row
total <- c(tract20_nbhd="Citywide", apply(hh_income_div_neigh[,-1], FUN = sum, MAR = 2))
hh_income_div_neigh <- rbind(hh_income_div_neigh, total)
hh_income_div_neigh <- cbind(hh_income_div_neigh, div_index_fxn(hh_income_div_neigh, "hh_income", "nbhd")[-1])
### CITY
cities_of_int <- readxl::read_xlsx("div_map_categories.xlsx", sheet = "cities")
cities_raw <- get_acs(geography = "place",
variable = acs_pull_labels, #34,
output = "wide",
year = 2020,
cache_table = T,
show_call = TRUE)
## Essentially, all the steps from earlier wil just be repeated here
cities_small <- cities_raw %>%
filter(NAME %in% unlist(cities_of_int)) %>%
select(!ends_with("M"))
rm(cities_raw)
# removing the E from the end of the variable names
colnames(cities_small)[3:length(colnames(cities_small))-1] <-
substr(colnames(cities_small)[3:length(colnames(cities_small))-1], 1, nchar(colnames(cities_small)[3:length(colnames(cities_small))-1])-1)
# adding the calculated rows to the census data #
# initializing the df
cities_groups <- tibble(GEOID = cities_small$GEOID,
NAME = cities_small$NAM) # I don't know why it's doing this but
for(i in 1:length(colnames(div_groups_labels))) {
cities_groups <- cbind(cities_groups, grouping_fxn(colnames(div_groups_labels)[i], city = T))
}
educ_pull_city_raw <- cities_groups %>%
select(c(GEOID, NAME, starts_with("educ")))
pob_pull_city_raw <- cities_groups %>%
select(c(GEOID, NAME, starts_with("pob")))
age_pull_city_raw <- cities_groups %>%
select(c(GEOID, NAME, starts_with("age")))
hh_income_pull_city_raw <- cities_groups %>%
select(c(GEOID, NAME, starts_with("hh_income")))
pob_div_city <- cbind(pob_pull_city_raw, div_index_fxn(pob_pull_city_raw, "pob", geography = "city")[-1])
educ_div_city <- cbind(educ_pull_city_raw, div_index_fxn(educ_pull_city_raw, "educ", geography = "city")[-1])
age_div_city <- cbind(age_pull_city_raw, div_index_fxn(age_pull_city_raw, "age", geography = "city")[-1])
hh_income_div_city <- cbind(hh_income_pull_city_raw, div_index_fxn(hh_income_pull_city_raw, "hh_income", geography = "city")[-1])
## WRITING OUT THE DATA ----------------------------------------------------
write_rds(pob_div_tract, "Place_of_Birth_diversity_tract.RDS")
write_rds(pob_div_neigh, "Place_of_Birth_diversity_neighborhood.RDS")
write_rds(pob_div_city, "Place_of_Birth_diversity_city.RDS")
write_rds(educ_div_tract, "Education_diversity_div_tract.RDS")
write_rds(educ_div_neigh, "Education_diversity_neighborhood.RDS")
write_rds(pob_div_city, "Education_diversity_div_city.RDS")
write_rds(age_div_tract, "Age_diversity_tract.RDS")
write_rds(age_div_neigh, "Age_diversity_neighborhood.RDS")
write_rds(pob_div_city, "Age_diversity_city.RDS")
write_rds(hh_income_div_tract, "Household_Income_diversity_tract.RDS")
write_rds(hh_income_div_neigh, "Household_Income_diversity_neighborhood.RDS")
write_rds(pob_div_city, "Household_Income_diversity_div_city.RDS")
write_rds(pob_div_city, "Household_Income_diversity_city.RDS")
write_rds(educ_div_tract, "Education_diversity_tract.RDS")
write_rds(pob_div_city, "Education_diversity_city.RDS")
