jank_minimum <- tract_df[tract_df$NAME == 'Census Tract 9815.01, Suffolk County, Massachusetts',]
jank_minimum$current_data <- 0
#jank_minimum$geometry <- list(list(c(-71.136596, -71.136273, 42.360161, 42.360903)))
jank_minimum$NAME <- 'min_val'
tract_df <- rbind(jank_minimum %>% st_as_sf(), tract_df)
jank_max <- tract_df[tract_df$NAME == 'Census Tract 9813, Suffolk County, Massachusetts',]
jank_max$current_data <- max_val
jank_max$NAME <- 'max_val'
tract_df <- rbind(jank_max, tract_df)
#tract_df <- tract_df %>% st_as_sf()
pal_option <- "RdYlBu"
# pal_option <- addalpha(pal_option, alpha = .5)
#pal <- colorQuantile(palette = pal_option, domain = tract_df$current_data, n = 5)
if (scale_bool){
#####FIGURE OUT WHY I NEED TO SUBTRACT 1
pal <- colorNumeric(palette = pal_option, domain = c(0, max_val),
na.color = "#505050")
legend_label <- "Diversity Index Score"
}else {
pal <- colorQuantile(palette = pal_option, domain = tract_df$current_data, n = 5)
legend_label <- "Percentile of Diversity Index"
}
tract_df %>%
mutate(current_data = ifelse(startsWith(NAME, "Census Tract 98"), NaN,current_data)) %>%
st_transform(crs = "+init=epsg:4326") %>%
leaflet() %>%
addTiles() %>%
addProviderTiles(provider = "CartoDB.Positron")  %>%
addPolygons(
stroke = F,
smoothFactor = 0,
fillOpacity = 0.7,
color = ~ pal(current_data), group = 'current_data') %>%
leafpop:::addPopupIframes(source = p_all, group = 'current_data') %>%
addLegend("bottomright",
pal = pal,
values = ~ current_data,
title = legend_label,
opacity = 1,
na.label = 'Tracts with little or no population')
View(p_all)
p_all <- paste0("./graph_files/", list.files(path = "./graph_files/", pattern = selected_val)) %>% readRDS()
tract_df %>%
mutate(current_data = ifelse(startsWith(NAME, "Census Tract 98"), NaN,current_data)) %>%
st_transform(crs = "+init=epsg:4326") %>%
leaflet() %>%
addTiles() %>%
addProviderTiles(provider = "CartoDB.Positron")  %>%
addPolygons(
stroke = F,
smoothFactor = 0,
fillOpacity = 0.7,
color = ~ pal(current_data), group = 'current_data') %>%
leafpop:::addPopupIframes(source = p_all, group = 'current_data') %>%
addLegend("bottomright",
pal = pal,
values = ~ current_data,
title = legend_label,
opacity = 1,
na.label = 'Tracts with little or no population')
paste0("./graph_files/", list.files(path = "./graph_files/", pattern = selected_val))
rm(list = ls())
library(tidycensus)
library(tidyverse)
library(leaflet)
library(leafpop)
library(mapview)
library(sf)
library(stringr)
library(plotly)
library(readr)
library(readxl)
library(stringr)
library(dplyr)
library(htmlwidgets)
# reading in all the data from the output folder
setwd("./output")
all_tract_data <- list.files(pattern = "tract.RDS") %>%
map(readRDS)
setwd("..")
# separating out the div values
for(i in 1:length(all_tract_data)) {
temp <- all_tract_data[[i]] %>% as_tibble()
var_name <- strsplit(colnames(temp)[4], "_")[[1]][1]
assign(paste0(var_name, "_values"), temp, envir = .GlobalEnv)
}
# need input and tract_df
PIE_CHART_TRACT_FUNC <- function(tract_name){
tract_df_graph <- tract_df_graph %>% filter(NAME == paste0(tract_name))
# labeling variables
pie_labels <- colnames(tract_df_graph) %>% str_sub(start = str_length(selected_val) + 2) %>% str_replace_all("_", " ")
pie_labels <- pie_labels %>% factor(levels = pie_labels, ordered = T)
pie_values <- as.numeric(as.vector(tract_df_graph[1,]))
# creating the graph
pie_chart <- plot_ly(labels = ~pie_labels, values = ~pie_values,
type = 'pie', sort = F,
marker = list(colors = c("#fdb462","#8dd3c7","#ffffb3","#bebada","#b3de69",
"#fccde5","#d9d9d9","#9c755f","#d37295","#00ffd0","#9467bd"))) %>%
layout(title = strsplit(paste0(tract_name), ",")[[1]][1],
xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
pie_chart
}
# uses tghe chart function to make all the charts per tracts
# and also converts it into a useable format
plot_html_fxn <- function(tract_df, input) {
# Gets rid of prefix. Used for starts with functionality
selected_val <- str_sub(input, start = 5)
# this filters out for only the variables of interest and
# this function goes on a tract-by-tract basis
tract_df_graph <- tract_df %>%
select(c(NAME, starts_with(selected_val)))
# this creates the chart for each tract and stores them as a list
p_all_plotly <- lapply(tract_df_graph$NAME, PIE_CHART_TRACT_FUNC)
# this writes the list file as an external html file
# this is nec to add as a popup in leaflet maps (idk why tho)
p_all_plotly_html <- lapply(p_all_plotly, function(plot) {
f1 = fl = tempfile(fileext = ".html")
saveWidget(plot, file = fl)
return(fl)
}
)
write_rds(p_all_plotly_html, paste0("graph_files/graph_", selected_val, ".RDS"))
}
# function to write input values
input_val_fxn <- function(tract_df) {
var <- strsplit(deparse(substitute(tract_df)), "_")[[1]][1]
input_vals <- colnames(tract_df)[grepl("^val_", colnames(tract_df))]
assign(paste0(var, "_input_vals"), input_vals, envir = .GlobalEnv)
}
input_val_fxn(age_values)
input_val_fxn(pob_values)
input_val_fxn(race_values)
input_val_fxn(hh_values)
input_val_fxn(lang_values)
input_val_fxn(educ_values)
for(i in 1:length(age_input_vals)) {
plot_html_fxn(age_values, age_input_vals[i])
}
# need input and tract_df
PIE_CHART_TRACT_FUNC <- function(tract_name, tract_df_graph){
tract_df_graph <- tract_df_graph %>% filter(NAME == paste0(tract_name))
# labeling variables
pie_labels <- colnames(tract_df_graph) %>% str_sub(start = str_length(selected_val) + 2) %>% str_replace_all("_", " ")
pie_labels <- pie_labels %>% factor(levels = pie_labels, ordered = T)
pie_values <- as.numeric(as.vector(tract_df_graph[1,]))
# creating the graph
pie_chart <- plot_ly(labels = ~pie_labels, values = ~pie_values,
type = 'pie', sort = F,
marker = list(colors = c("#fdb462","#8dd3c7","#ffffb3","#bebada","#b3de69",
"#fccde5","#d9d9d9","#9c755f","#d37295","#00ffd0","#9467bd"))) %>%
layout(title = strsplit(paste0(tract_name), ",")[[1]][1],
xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
pie_chart
}
# uses tghe chart function to make all the charts per tracts
# and also converts it into a useable format
plot_html_fxn <- function(tract_df, input) {
# Gets rid of prefix. Used for starts with functionality
selected_val <- str_sub(input, start = 5)
# this filters out for only the variables of interest and
# this function goes on a tract-by-tract basis
tract_df_graph <- tract_df %>%
select(c(NAME, starts_with(selected_val)))
# this creates the chart for each tract and stores them as a list
p_all_plotly <- lapply(tract_df_graph$NAME, PIE_CHART_TRACT_FUNC(tract_df_graph = tract_df_graph))
# this writes the list file as an external html file
# this is nec to add as a popup in leaflet maps (idk why tho)
p_all_plotly_html <- lapply(p_all_plotly, function(plot) {
f1 = fl = tempfile(fileext = ".html")
saveWidget(plot, file = fl)
return(fl)
}
)
write_rds(p_all_plotly_html, paste0("graph_files/graph_", selected_val, ".RDS"))
}
for(i in 1:length(age_input_vals)) {
plot_html_fxn(age_values, age_input_vals[i])
}
tract_df <- age_values
# Gets rid of prefix. Used for starts with functionality
selected_val <- str_sub(input, start = 5)
input <- age_input_vals[1]
# Gets rid of prefix. Used for starts with functionality
selected_val <- str_sub(input, start = 5)
# this filters out for only the variables of interest and
# this function goes on a tract-by-tract basis
tract_df_graph <- tract_df %>%
select(c(NAME, starts_with(selected_val)))
View(tract_df_graph)
rm(list = ls())
library(tidycensus)
library(tidyverse)
library(leaflet)
library(leafpop)
library(mapview)
library(sf)
library(stringr)
library(plotly)
library(readr)
library(readxl)
library(stringr)
library(dplyr)
library(htmlwidgets)
# reading in all the data from the output folder
setwd("./output")
all_tract_data <- list.files(pattern = "tract.RDS") %>%
map(readRDS)
setwd("..")
# separating out the div values
for(i in 1:length(all_tract_data)) {
temp <- all_tract_data[[i]] %>% as_tibble()
var_name <- strsplit(colnames(temp)[4], "_")[[1]][1]
assign(paste0(var_name, "_values"), temp, envir = .GlobalEnv)
}
# need input and tract_df
PIE_CHART_TRACT_FUNC <- function(tract_name){
tract_df_graph <- tract_df %>%
select(c(NAME, starts_with(selected_val)))
tract_df_graph <- tract_df_graph %>% filter(NAME == paste0(tract_name))
# labeling variables
pie_labels <- colnames(tract_df_graph) %>% str_sub(start = str_length(selected_val) + 2) %>% str_replace_all("_", " ")
pie_labels <- pie_labels %>% factor(levels = pie_labels, ordered = T)
pie_values <- as.numeric(as.vector(tract_df_graph[1,]))
# creating the graph
pie_chart <- plot_ly(labels = ~pie_labels, values = ~pie_values,
type = 'pie', sort = F,
marker = list(colors = c("#fdb462","#8dd3c7","#ffffb3","#bebada","#b3de69",
"#fccde5","#d9d9d9","#9c755f","#d37295","#00ffd0","#9467bd"))) %>%
layout(title = strsplit(paste0(tract_name), ",")[[1]][1],
xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
pie_chart
}
# uses tghe chart function to make all the charts per tracts
# and also converts it into a useable format
plot_html_fxn <- function(tract_df, input) {
# Gets rid of prefix. Used for starts with functionality
selected_val <- str_sub(input, start = 5)
# this creates the chart for each tract and stores them as a list
p_all_plotly <- lapply(tract_df_graph$NAME, PIE_CHART_TRACT_FUNC)
# this writes the list file as an external html file
# this is nec to add as a popup in leaflet maps (idk why tho)
p_all_plotly_html <- lapply(p_all_plotly, function(plot) {
f1 = fl = tempfile(fileext = ".html")
saveWidget(plot, file = fl)
return(fl)
}
)
write_rds(p_all_plotly_html, paste0("graph_files/graph_", selected_val, ".RDS"))
}
# function to write input values
input_val_fxn <- function(tract_df) {
var <- strsplit(deparse(substitute(tract_df)), "_")[[1]][1]
input_vals <- colnames(tract_df)[grepl("^val_", colnames(tract_df))]
assign(paste0(var, "_input_vals"), input_vals, envir = .GlobalEnv)
}
input_val_fxn(age_values)
input_val_fxn(pob_values)
input_val_fxn(race_values)
input_val_fxn(hh_values)
input_val_fxn(lang_values)
input_val_fxn(educ_values)
for(i in 1:length(age_input_vals)) {
plot_html_fxn(age_values, age_input_vals[i])
}
# uses tghe chart function to make all the charts per tracts
# and also converts it into a useable format
plot_html_fxn <- function(tract_df, input) {
# Gets rid of prefix. Used for starts with functionality
selected_val <- str_sub(input, start = 5)
# this creates the chart for each tract and stores them as a list
p_all_plotly <- lapply(tract_df$NAME, PIE_CHART_TRACT_FUNC)
# this writes the list file as an external html file
# this is nec to add as a popup in leaflet maps (idk why tho)
p_all_plotly_html <- lapply(p_all_plotly, function(plot) {
f1 = fl = tempfile(fileext = ".html")
saveWidget(plot, file = fl)
return(fl)
}
)
write_rds(p_all_plotly_html, paste0("graph_files/graph_", selected_val, ".RDS"))
}
# function to write input values
input_val_fxn <- function(tract_df) {
var <- strsplit(deparse(substitute(tract_df)), "_")[[1]][1]
input_vals <- colnames(tract_df)[grepl("^val_", colnames(tract_df))]
assign(paste0(var, "_input_vals"), input_vals, envir = .GlobalEnv)
}
input_val_fxn(age_values)
input_val_fxn(pob_values)
input_val_fxn(race_values)
input_val_fxn(hh_values)
input_val_fxn(lang_values)
input_val_fxn(educ_values)
for(i in 1:length(age_input_vals)) {
plot_html_fxn(age_values, age_input_vals[i])
}
tract_df <- age_values
input <- age_input_vals[1]
# Gets rid of prefix. Used for starts with functionality
selected_val <- str_sub(input, start = 5)
tract_df_graph <- tract_df %>%
select(c(NAME, starts_with(selected_val)))
View(tract_df_graph)
rm(list = ls())
library(tidycensus)
library(tidyverse)
library(leaflet)
library(leafpop)
library(mapview)
library(sf)
library(stringr)
library(plotly)
library(readr)
library(readxl)
library(stringr)
library(dplyr)
library(htmlwidgets)
# reading in all the data from the output folder
setwd("./output")
all_tract_data <- list.files(pattern = "tract.RDS") %>%
map(readRDS)
setwd("..")
# separating out the div values
for(i in 1:length(all_tract_data)) {
temp <- all_tract_data[[i]] %>% as_tibble()
var_name <- strsplit(colnames(temp)[4], "_")[[1]][1]
assign(paste0(var_name, "_values"), temp, envir = .GlobalEnv)
}
# need input and tract_df
PIE_CHART_TRACT_FUNC <- function(tract_name, tract_df_graph){
tract_df_graph <- tract_df_graph %>% filter(NAME == paste0(tract_name))
# labeling variables
pie_labels <- colnames(tract_df_graph) %>% str_sub(start = str_length(selected_val) + 2) %>% str_replace_all("_", " ")
pie_labels <- pie_labels %>% factor(levels = pie_labels, ordered = T)
pie_values <- as.numeric(as.vector(tract_df_graph[1,]))
# creating the graph
pie_chart <- plot_ly(labels = ~pie_labels, values = ~pie_values,
type = 'pie', sort = F,
marker = list(colors = c("#fdb462","#8dd3c7","#ffffb3","#bebada","#b3de69",
"#fccde5","#d9d9d9","#9c755f","#d37295","#00ffd0","#9467bd"))) %>%
layout(title = strsplit(paste0(tract_name), ",")[[1]][1],
xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
pie_chart
}
# uses tghe chart function to make all the charts per tracts
# and also converts it into a useable format
plot_html_fxn <- function(tract_df, input) {
# Gets rid of prefix. Used for starts with functionality
selected_val <- str_sub(input, start = 5)
tract_df_graph <- tract_df %>%
select(c(NAME, starts_with(selected_val)))
# this creates the chart for each tract and stores them as a list
p_all_plotly <- lapply(tract_df$NAME, PIE_CHART_TRACT_FUNC, tract_df_graph = tract_df_graph)
# this writes the list file as an external html file
# this is nec to add as a popup in leaflet maps (idk why tho)
p_all_plotly_html <- lapply(p_all_plotly, function(plot) {
f1 = fl = tempfile(fileext = ".html")
saveWidget(plot, file = fl)
return(fl)
}
)
write_rds(p_all_plotly_html, paste0("graph_files/graph_", selected_val, ".RDS"))
}
# function to write input values
input_val_fxn <- function(tract_df) {
var <- strsplit(deparse(substitute(tract_df)), "_")[[1]][1]
input_vals <- colnames(tract_df)[grepl("^val_", colnames(tract_df))]
assign(paste0(var, "_input_vals"), input_vals, envir = .GlobalEnv)
}
input_val_fxn(age_values)
input_val_fxn(pob_values)
input_val_fxn(race_values)
input_val_fxn(hh_values)
input_val_fxn(lang_values)
input_val_fxn(educ_values)
for(i in 1:length(age_input_vals)) {
plot_html_fxn(age_values, age_input_vals[i])
}
rm(list = ls())
library(tidycensus)
library(tidyverse)
library(leaflet)
library(leafpop)
library(mapview)
library(sf)
library(stringr)
library(plotly)
library(readr)
library(readxl)
library(stringr)
library(dplyr)
library(htmlwidgets)
# reading in all the data from the output folder
setwd("./output")
all_tract_data <- list.files(pattern = "tract.RDS") %>%
map(readRDS)
setwd("..")
# separating out the div values
for(i in 1:length(all_tract_data)) {
temp <- all_tract_data[[i]] %>% as_tibble()
var_name <- strsplit(colnames(temp)[4], "_")[[1]][1]
assign(paste0(var_name, "_values"), temp, envir = .GlobalEnv)
}
# need input and tract_df
PIE_CHART_TRACT_FUNC <- function(tract_name, tract_df_graph, selected_val){
tract_df_graph <- tract_df_graph %>% filter(NAME == paste0(tract_name))
# labeling variables
pie_labels <- colnames(tract_df_graph) %>% str_sub(start = str_length(selected_val) + 2) %>% str_replace_all("_", " ")
pie_labels <- pie_labels %>% factor(levels = pie_labels, ordered = T)
pie_values <- as.numeric(as.vector(tract_df_graph[1,]))
# creating the graph
pie_chart <- plot_ly(labels = ~pie_labels, values = ~pie_values,
type = 'pie', sort = F,
marker = list(colors = c("#fdb462","#8dd3c7","#ffffb3","#bebada","#b3de69",
"#fccde5","#d9d9d9","#9c755f","#d37295","#00ffd0","#9467bd"))) %>%
layout(title = strsplit(paste0(tract_name), ",")[[1]][1],
xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
pie_chart
}
# uses tghe chart function to make all the charts per tracts
# and also converts it into a useable format
plot_html_fxn <- function(tract_df, input) {
# Gets rid of prefix. Used for starts with functionality
selected_val <- str_sub(input, start = 5)
tract_df_graph <- tract_df %>%
select(c(NAME, starts_with(selected_val)))
# this creates the chart for each tract and stores them as a list
p_all_plotly <- lapply(tract_df$NAME, PIE_CHART_TRACT_FUNC,
tract_df_graph = tract_df_graph,
selected_val = selected_val)
# this writes the list file as an external html file
# this is nec to add as a popup in leaflet maps (idk why tho)
p_all_plotly_html <- lapply(p_all_plotly, function(plot) {
f1 = fl = tempfile(fileext = ".html")
saveWidget(plot, file = fl)
return(fl)
}
)
write_rds(p_all_plotly_html, paste0("graph_files/graph_", selected_val, ".RDS"))
}
# function to write input values
input_val_fxn <- function(tract_df) {
var <- strsplit(deparse(substitute(tract_df)), "_")[[1]][1]
input_vals <- colnames(tract_df)[grepl("^val_", colnames(tract_df))]
assign(paste0(var, "_input_vals"), input_vals, envir = .GlobalEnv)
}
input_val_fxn(age_values)
input_val_fxn(pob_values)
input_val_fxn(race_values)
input_val_fxn(hh_values)
input_val_fxn(lang_values)
input_val_fxn(educ_values)
for(i in 1:length(age_input_vals)) {
plot_html_fxn(age_values, age_input_vals[i])
}
p_all <- paste0("./graph_files/", list.files(path = "./graph_files/", pattern = selected_val)) %>% readRDS()
input <- "val_age_all"
tract_df <- age_values
scale_bool <- T
tract_df <- tract_df %>% st_as_sf()
selected_val <- str_sub(input, start = 5)
tract_df$current_data <- tract_df[[input]]
NUM_VARIABLES <- tract_df %>%
select(starts_with(selected_val)) %>%
ncol() - 1
max_val <- 1 - (1/(NUM_VARIABLES))
jank_minimum <- tract_df[tract_df$NAME == 'Census Tract 9815.01, Suffolk County, Massachusetts',]
jank_minimum$current_data <- 0
#jank_minimum$geometry <- list(list(c(-71.136596, -71.136273, 42.360161, 42.360903)))
jank_minimum$NAME <- 'min_val'
tract_df <- rbind(jank_minimum %>% st_as_sf(), tract_df)
jank_max <- tract_df[tract_df$NAME == 'Census Tract 9813, Suffolk County, Massachusetts',]
jank_max$current_data <- max_val
jank_max$NAME <- 'max_val'
tract_df <- rbind(jank_max, tract_df)
#tract_df <- tract_df %>% st_as_sf()
pal_option <- "RdYlBu"
# pal_option <- addalpha(pal_option, alpha = .5)
#pal <- colorQuantile(palette = pal_option, domain = tract_df$current_data, n = 5)
if (scale_bool){
#####FIGURE OUT WHY I NEED TO SUBTRACT 1
pal <- colorNumeric(palette = pal_option, domain = c(0, max_val),
na.color = "#505050")
legend_label <- "Diversity Index Score"
}else {
pal <- colorQuantile(palette = pal_option, domain = tract_df$current_data, n = 5)
legend_label <- "Percentile of Diversity Index"
}
p_all <- paste0("./graph_files/", list.files(path = "./graph_files/", pattern = selected_val)) %>% readRDS()
tract_df %>%
mutate(current_data = ifelse(startsWith(NAME, "Census Tract 98"), NaN,current_data)) %>%
st_transform(crs = "+init=epsg:4326") %>%
leaflet() %>%
addTiles() %>%
addProviderTiles(provider = "CartoDB.Positron")  %>%
addPolygons(
stroke = F,
smoothFactor = 0,
fillOpacity = 0.7,
color = ~ pal(current_data), group = 'current_data') %>%
leafpop:::addPopupIframes(source = p_all, group = 'current_data') %>%
addLegend("bottomright",
pal = pal,
values = ~ current_data,
title = legend_label,
opacity = 1,
na.label = 'Tracts with little or no population')
