var <- strsplit(deparse(substitute(pull_raw)), "_")[[1]][1]
# selecting the proper data
pull_city_raw <- cities_groups %>%
select(c(GEOID, NAME, starts_with(var)))
# calculating the index and combining
div_city <- cbind(pull_city_raw, div_index_fxn(pull_city_raw, var, geography = "city")[-1])
write_rds(div_city, paste0("output/", var, "_diversity_cities.RDS"))
}
## WRITING OUT THE DATA ----------------------------------------------------
tract_calc_fxn(race_pull_raw)
nbhd_calc_fxn(race_pull_raw)
city_calc_fxn(race_pull_raw)
tract_calc_fxn(educ_pull_raw)
nbhd_calc_fxn(educ_pull_raw)
city_calc_fxn(educ_pull_raw)
tract_calc_fxn(lang_pull_raw)
nbhd_calc_fxn(lang_pull_raw)
city_calc_fxn(lang_pull_raw)
tract_calc_fxn(age_pull_raw)
nbhd_calc_fxn(age_pull_raw)
city_calc_fxn(age_pull_raw)
tract_calc_fxn(hh_pull_raw)
nbhd_calc_fxn(hh_pull_raw)
city_calc_fxn(hh_pull_raw)
tract_calc_fxn(pob_pull_raw)
nbhd_calc_fxn(pob_pull_raw)
city_calc_fxn(pob_pull_raw)
## READING IN THE DATA ----------------------------------------------------
# age_div_tract <- read_rds("data/Age_diversity_tract.RDS") #%>%
# mutate(current_data = val_gens)
# age_div_neigh <- read_rds("data/Age_diversity_neighborhood.RDS")
# age_div_cities <- read_rds("data/Age_diversity_cities.RDS")
#
# educ_div_tract <- read_rds("data/Education_diversity_tract.RDS") %>%
#   mutate(current_data = val_higher_ed)
# educ_div_neigh <- read_rds("data/Education_diversity_neighborhood.RDS")
# educ_div_cities <- read_rds("data/Education_diversity_cities.RDS")
#
# hh_income_div_tract <- read_rds("data/Household_Income_diversity_tract.RDS") %>%
#   mutate(current_data = val_median)
# hh_income_div_neigh <- read_rds("data/Household_Income_diversity_neighborhood.RDS")
# hh_income_div_cities <- read_rds("data/Household_Income_diversity_cities.RDS")
#
# lang_div_tract <- read_rds("data/Language_diversity_tract.RDS") %>%
#   mutate(current_data = val_eng_not)
# lang_div_neigh <- read_rds("data/Language_diversity_neighborhood.RDS")
# lang_div_cities <- read_rds("data/Language_diversity_cities.RDS")
#
# pob_div_tract <- read_rds("data/Place_of_Birth_diversity_tract.RDS") %>%
#   mutate(current_data = val_nat_for)
# pob_div_neigh <- read_rds("data/Place_of_Birth_diversity_neighborhood.RDS")
# pob_div_cities <- read_rds("data/Place_of_Birth_diversity_cities.RDS")
# removing the E from the end of the variable names
colnames(cities_raw)[3:length(colnames(cities_raw))-1] <-
substr(colnames(cities_raw)[3:length(colnames(cities_raw))-1], 1, nchar(colnames(cities_raw)[3:length(colnames(cities_raw))-1])-1)
# initializing the df
cities_raw_groups <- tibble(GEOID = cities_raw$GEOID,
NAME = cities_raw$NAM) # I don't know why it's doing this but
for(i in 1:length(colnames(div_groups_labels))) {
cities_raw_groups <- cbind(cities_raw_groups, grouping_fxn(colnames(div_groups_labels)[i], city = T))
}
View(cities_raw_groups)
View(cities_groups)
View(cities_raw)
View(cities_of_int)
View(cities_raw)
View(cities_raw_groups)
div_groups_labels
length(colnames(div_groups_labels)
)
View(cities_raw)
i <- 2
grouping_fxn(colnames(div_groups_labels)[i], city = T)
grouping_fxn <- function(div_label, city = F) {
x <- which(colnames(div_groups_labels) == paste0(div_label))
if(city == T){
other_var_small <- cities_raw
}
# this basically selects the relevant census variables related to each group
# and then adds them
dat <- other_var_small %>%
as_tibble() %>%
select(
colnames(other_var_small)[colnames(other_var_small) %in% (div_groups_labels[,x] %>% array())[[1]]]
) %>%
mutate(val = rowSums(across())) %>% select(val) %>%
rename(!!sym(div_label) := val)
return(dat)
}
rm(i)
for(i in 1:length(colnames(div_groups_labels))) {
cities_raw_groups <- cbind(cities_raw_groups, grouping_fxn(colnames(div_groups_labels)[i], city = T))
}
cities_raw <- get_acs(geography = "place",
variable = acs_pull_labels, #34,
output = "wide",
year = 2021,
cache_table = T,
show_call = TRUE)
cities_raw <- cities_raw %>%
select(!ends_with("M"))
# removing the E from the end of the variable names
colnames(cities_raw)[3:length(colnames(cities_raw))-1] <-
substr(colnames(cities_raw)[3:length(colnames(cities_raw))-1], 1, nchar(colnames(cities_raw)[3:length(colnames(cities_raw))-1])-1)
# initializing the df
cities_raw_groups <- tibble(GEOID = cities_raw$GEOID,
NAME = cities_raw$NAM) # I don't know why it's doing this but
grouping_fxn <- function(div_label, city = F) {
x <- which(colnames(div_groups_labels) == paste0(div_label))
if(city == T){
other_var_small <- cities_raw
}
# this basically selects the relevant census variables related to each group
# and then adds them
dat <- other_var_small %>%
as_tibble() %>%
select(
colnames(other_var_small)[colnames(other_var_small) %in% (div_groups_labels[,x] %>% array())[[1]]]
) %>%
mutate(val = rowSums(across())) %>% select(val) %>%
rename(!!sym(div_label) := val)
return(dat)
}
for(i in 1:length(colnames(div_groups_labels))) {
cities_raw_groups <- cbind(cities_raw_groups, grouping_fxn(colnames(div_groups_labels)[i], city = T))
}
# city calculation function
pull_raw <- educ_pull_raw
var <- strsplit(deparse(substitute(pull_raw)), "_")[[1]][1]
# selecting the proper data
pull_city_raw <- cities_raw_groups %>%
select(c(GEOID, NAME, starts_with(var)))
# calculating the index and combining
div_city <- cbind(pull_city_raw, div_index_fxn(pull_city_raw, var, geography = "city")[-1])
View(pull_city_raw)
View(cities_raw_groups)
library(writexl)
write_xlsx(cities_raw_groups, "all_cities_counts_2023.03.31")
write_xlsx(cities_raw_groups, "all_cities_counts_2023.03.31.xlsx")
cities_raw_groups %>% filter(str_detect("city"))
rlang::last_trace()
library(stringr)
View(cities_raw_groups)
cities_raw_groups %>% filter(str_detect(NAME, "city"))
write_xlsx(cities_raw_groups %>% filter(str_detect(NAME, "city")), "all_cities_counts_2023.03.31.xlsx")
rm(list = ls())
library(tidycensus)
library(tidyverse)
library(leaflet)
library(leafpop)
library(mapview)
library(sf)
library(stringr)
library(plotly)
library(readr)
library(readxl)
library(stringr)
library(dplyr)
library(htmlwidgets)
# reading in all the data from the output folder
setwd("./output")
all_tract_data <- list.files(pattern = "tract.RDS") %>%
map(readRDS)
setwd("..")
# separating out the div values
for(i in 1:length(all_tract_data)) {
temp <- all_tract_data[[i]] %>% as_tibble()
var_name <- strsplit(colnames(temp)[4], "_")[[1]][1]
assign(paste0(var_name, "_values"), temp, envir = .GlobalEnv)
}
# labeling functionsd
pie_legend_label_fxn <- function(pie_label_name) {
return(paste(strwrap(pie_label_name, width = 25), collapse = "<br>"))
}
# need input and tract_df
PIE_CHART_TRACT_FUNC <- function(tract_name){
tract_df_graph <- tract_df_graph %>% filter(NAME == paste0(tract_name))
# labeling variables
pie_labels <- colnames(tract_df_graph) %>% str_sub(start = str_length(selected_val) + 2) %>% str_replace_all("_", " ")
pie_labels <- lapply(pie_labels, pie_legend_label_fxn) %>% unlist()
pie_labels <- pie_labels %>% factor(levels = pie_labels, ordered = T)
pie_values <- as.numeric(as.vector(tract_df_graph[1,]))
# creating the graph
pie_chart <- plot_ly(labels = ~pie_labels, values = ~pie_values,
type = 'pie', sort = F,
marker = list(colors = c("#fdb462","#8dd3c7","#ffffb3","#bebada","#b3de69",
"#fccde5","#d9d9d9","#9c755f","#d37295","#00ffd0","#9467bd"))) %>%
layout(title = strsplit(paste0(tract_name), ",")[[1]][1],
xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
pie_chart
}
# uses tghe chart function to make all the charts per tracts
# and also converts it into a useable format
plot_html_fxn <- function(tract_df, input) {
# Gets rid of prefix. Used for starts with functionality
selected_val <- str_sub(input, start = 5)
# this filters out for only the variables of interest and
# this function goes on a tract-by-tract basis
tract_df_graph <- tract_df %>%
select(c(NAME, starts_with(selected_val)))
# this creates the chart for each tract and stores them as a list
p_all_plotly <- lapply(tract_df_graph$NAME, PIE_CHART_TRACT_FUNC)
# this writes the list file as an external html file
# this is nec to add as a popup in leaflet maps (idk why tho)
p_all_plotly_html <- lapply(p_all_plotly, function(plot) {
f1 = fl = tempfile(fileext = ".html")
saveWidget(plot, file = fl)
return(fl)
}
)
write_rds(p_all_plotly_html, paste0("graph_files/graph_", selected_val, ".RDS"))
}
plot_output_fxn <- function(tract_df) {
input_vals <- colnames(tract_df)[grepl("^val_", colnames(tract_df))]
for(i in 1:length(input_vals)) {
plot_html_fxn(tract_df = tract_df, input_vals[i])
}
}
plot_output_fxn(race_values)
plot_output_fxn <- function(tract_df) {
input_vals <- colnames(tract_df)[grepl("^val_", colnames(tract_df))]
for(i in 1:length(input_vals)) {
plot_html_fxn(tract_df = pasteo(tract_df), input_vals[i])
}
}
plot_output_fxn(race_values)
plot_output_fxn <- function(tract_df) {
input_vals <- colnames(tract_df)[grepl("^val_", colnames(tract_df))]
for(i in 1:length(input_vals)) {
plot_html_fxn(tract_df = paste0(tract_df), input_vals[i])
}
}
plot_output_fxn(race_values)
plot_output_fxn <- function(var_tract_df) {
input_vals <- colnames(var_tract_df)[grepl("^val_", colnames(var_tract_df))]
for(i in 1:length(input_vals)) {
plot_html_fxn(tract_df = var_tract_df, input_vals[i])
}
}
plot_output_fxn(race_values)
rm(list = ls())
library(tidycensus)
library(tidyverse)
library(leaflet)
library(leafpop)
library(mapview)
library(sf)
library(stringr)
library(plotly)
library(readr)
library(readxl)
library(stringr)
library(dplyr)
library(htmlwidgets)
# reading in all the data from the output folder
setwd("./output")
all_tract_data <- list.files(pattern = "tract.RDS") %>%
map(readRDS)
setwd("..")
# separating out the div values
for(i in 1:length(all_tract_data)) {
temp <- all_tract_data[[i]] %>% as_tibble()
var_name <- strsplit(colnames(temp)[4], "_")[[1]][1]
assign(paste0(var_name, "_values"), temp, envir = .GlobalEnv)
}
# need input and tract_df
PIE_CHART_TRACT_FUNC <- function(tract_name, tract_df_graph, selected_val){
tract_df_graph <- tract_df_graph %>% filter(NAME == paste0(tract_name))
# labeling variables
pie_labels <- colnames(tract_df_graph) %>% str_sub(start = str_length(selected_val) + 2) %>% str_replace_all("_", " ")
pie_labels <- pie_labels %>% factor(levels = pie_labels, ordered = T)
pie_values <- as.numeric(as.vector(tract_df_graph[1,]))
# creating the graph
pie_chart <- plot_ly(labels = ~pie_labels, values = ~pie_values,
type = 'pie', sort = F,
marker = list(colors = c("#fdb462","#8dd3c7","#ffffb3","#bebada","#b3de69",
"#fccde5","#d9d9d9","#9c755f","#d37295","#00ffd0","#9467bd"))) %>%
layout(title = strsplit(paste0(tract_name), ",")[[1]][1],
xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
pie_chart
}
# uses tghe chart function to make all the charts per tracts
# and also converts it into a useable format
plot_html_fxn <- function(tract_df, input) {
# Gets rid of prefix. Used for starts with functionality
selected_val <- str_sub(input, start = 5)
tract_df_graph <- tract_df %>%
select(c(NAME, starts_with(selected_val)))
# this creates the chart for each tract and stores them as a list
p_all_plotly <- lapply(tract_df$NAME, PIE_CHART_TRACT_FUNC,
tract_df_graph = tract_df_graph,
selected_val = selected_val)
# this writes the list file as an external html file
# this is nec to add as a popup in leaflet maps (idk why tho)
p_all_plotly_html <- lapply(p_all_plotly, function(plot) {
f1 = fl = tempfile(fileext = ".html")
saveWidget(plot, file = fl)
return(fl)
}
)
write_rds(p_all_plotly_html, paste0("graph_files/graph_", selected_val, ".RDS"))
}
# function to write input values
input_val_fxn <- function(tract_df) {
var <- strsplit(deparse(substitute(tract_df)), "_")[[1]][1]
input_vals <- colnames(tract_df)[grepl("^val_", colnames(tract_df))]
assign(paste0(var, "_input_vals"), input_vals, envir = .GlobalEnv)
}
# in case the oter thing (below) doesn't work
plot_output_fxn <- function(tract_df) {
input_vals <- colnames(tract_df)[grepl("^val_", colnames(tract_df))]
for(i in 1:length(input_vals)) {
plot_html_fxn(tract_df = tract_df, input_vals[i])
}
}
plot_output_fxn(race_values)
input <- "val_age_all"
tract_df <- age_values
scale_bool <- T
tract_df <- tract_df %>% st_as_sf()
selected_val <- str_sub(input, start = 5)
tract_df$current_data <- tract_df[[input]]
NUM_VARIABLES <- tract_df %>%
select(starts_with(selected_val)) %>%
ncol() - 1
max_val <- 1 - (1/(NUM_VARIABLES))
jank_minimum <- tract_df[tract_df$NAME == 'Census Tract 9815.01, Suffolk County, Massachusetts',]
jank_minimum$current_data <- 0
#jank_minimum$geometry <- list(list(c(-71.136596, -71.136273, 42.360161, 42.360903)))
jank_minimum$NAME <- 'min_val'
tract_df <- rbind(jank_minimum %>% st_as_sf(), tract_df)
jank_max <- tract_df[tract_df$NAME == 'Census Tract 9813, Suffolk County, Massachusetts',]
jank_max$current_data <- max_val
jank_max$NAME <- 'max_val'
tract_df <- rbind(jank_max, tract_df)
#tract_df <- tract_df %>% st_as_sf()
pal_option <- "RdYlBu"
# pal_option <- addalpha(pal_option, alpha = .5)
#pal <- colorQuantile(palette = pal_option, domain = tract_df$current_data, n = 5)
if (scale_bool){
#####FIGURE OUT WHY I NEED TO SUBTRACT 1
pal <- colorNumeric(palette = pal_option, domain = c(0, max_val),
na.color = "#505050")
legend_label <- "Diversity Index Score"
}else {
pal <- colorQuantile(palette = pal_option, domain = tract_df$current_data, n = 5)
legend_label <- "Percentile of Diversity Index"
}
p_all <- paste0("./graph_files/", list.files(path = "./graph_files/", pattern = selected_val)) %>% readRDS()
tract_df %>%
mutate(current_data = ifelse(startsWith(NAME, "Census Tract 98"), NaN,current_data)) %>%
st_transform(crs = "+init=epsg:4326") %>%
leaflet() %>%
addTiles() %>%
addProviderTiles(provider = "CartoDB.Positron")  %>%
addPolygons(
stroke = F,
smoothFactor = 0,
fillOpacity = 0.7,
color = ~ pal(current_data), group = 'current_data') %>%
leafpop:::addPopupIframes(source = p_all, group = 'current_data') %>%
addLegend("bottomright",
pal = pal,
values = ~ current_data,
title = legend_label,
opacity = 1,
na.label = 'Tracts with little or no population')
s <- Rhttpd$new()
install.packages("Rhttpd")
df = read.csv(textConnection(
"Name,Lat,Long
Samurai Noodle,47.597131,-122.327298
Another Place,47.687,-121.753"
))
p = Map(
function(x, y) {
df = data.frame(x = x, y = y)
plot_ly(data=df, x=~x, y=~y, type="scatter")
}
, x = list(1:10, 3:12)
, y = list(10:1, 1:10)
)
fl = lapply(
p
, function(j) {
fl = tempfile(fileext = ".html")
saveWidget(j, file = fl)
return(fl)
}
)
leaflet(df) %>% addTiles() %>%
addMarkers(
~Long
, ~Lat
, group="3"
) %>%
leafpop:::addPopupIframes(
source = fl
, group = "3"
)
?Rhttpd
?rgui
install.packages("RGui")
tract_df %>%
mutate(current_data = ifelse(startsWith(NAME, "Census Tract 98"), NaN,current_data)) %>%
st_transform(crs = "+init=epsg:4326") %>%
leaflet() %>%
addTiles() %>%
addProviderTiles(provider = "CartoDB.Positron")  %>%
addPolygons(
stroke = F,
smoothFactor = 0,
fillOpacity = 0.7,
color = ~ pal(current_data), group = 'current_data') %>%
leafpop:::addPopupIframes(source = p_all, group = 'current_data') %>%
addLegend("bottomright",
pal = pal,
values = ~ current_data,
title = legend_label,
opacity = 1,
na.label = 'Tracts with little or no population')
print(tools::startDynamicHelp(NA))
install.packages("Rook")
help.start()
library(Rook)
install.packages("Rook", dependencies = TRUE, INSTALL_opts = '--no-lock')
options(install.lock = FALSE)
install.packages("Rook", dependencies = TRUE, INSTALL_opts = '--no-lock')
s <- Rhttpd$new()
library(Rook)
s <- Rhttpd$new()
s$start(listen="0.0.0.0",port="20000")
tract_df %>%
mutate(current_data = ifelse(startsWith(NAME, "Census Tract 98"), NaN,current_data)) %>%
st_transform(crs = "+init=epsg:4326") %>%
leaflet() %>%
addTiles() %>%
addProviderTiles(provider = "CartoDB.Positron")  %>%
addPolygons(
stroke = F,
smoothFactor = 0,
fillOpacity = 0.7,
color = ~ pal(current_data), group = 'current_data') %>%
leafpop:::addPopupIframes(source = p_all, group = 'current_data') %>%
addLegend("bottomright",
pal = pal,
values = ~ current_data,
title = legend_label,
opacity = 1,
na.label = 'Tracts with little or no population')
library(tidycensus)
library(tidyverse)
library(leaflet)
library(leafpop)
library(mapview)
library(sf)
library(stringr)
library(plotly)
library(readr)
library(readxl)
library(stringr)
library(dplyr)
library(htmlwidgets)
tract_df %>%
mutate(current_data = ifelse(startsWith(NAME, "Census Tract 98"), NaN,current_data)) %>%
st_transform(crs = "+init=epsg:4326") %>%
leaflet() %>%
addTiles() %>%
addProviderTiles(provider = "CartoDB.Positron")  %>%
addPolygons(
stroke = F,
smoothFactor = 0,
fillOpacity = 0.7,
color = ~ pal(current_data), group = 'current_data') %>%
leafpop:::addPopupIframes(source = p_all, group = 'current_data') %>%
addLegend("bottomright",
pal = pal,
values = ~ current_data,
title = legend_label,
opacity = 1,
na.label = 'Tracts with little or no population')
help.start()
print(tools::startDynamicHelp(NA))
tract_df %>%
mutate(current_data = ifelse(startsWith(NAME, "Census Tract 98"), NaN,current_data)) %>%
st_transform(crs = "+init=epsg:4326") %>%
leaflet() %>%
addTiles() %>%
addProviderTiles(provider = "CartoDB.Positron")  %>%
addPolygons(
stroke = F,
smoothFactor = 0,
fillOpacity = 0.7,
color = ~ pal(current_data), group = 'current_data') %>%
leafpop:::addPopupIframes(source = p_all, group = 'current_data') %>%
addLegend("bottomright",
pal = pal,
values = ~ current_data,
title = legend_label,
opacity = 1,
na.label = 'Tracts with little or no population')
R.Version()
graph_race_multiracial <- readRDS("~/GitHub/Diversity-Map/graph_files/graph_race_multiracial.RDS")
View(graph_race_multiracial)
graph_race_multiracial[[1]]
install.packages("config")
library(config)
config::get("dataconnection")
config::get
addResourcePath("library", "~/lib64/R/library")
